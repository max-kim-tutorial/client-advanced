# 리액트 클린 코드

과제 전형 대비해서,, 좀 정리해보자  
어째 미디엄엔 리액트 코드컨벤션 이야기가 많은것 같긔 

## 리액트 클린코드 기본

https://velog.io/@hyounglee/checklist-codereview  
https://velog.io/@huurray/SOLID-%EC%9B%90%EC%B9%99%EC%97%90-%EA%B8%B0%EC%B4%88%ED%95%9C-React-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%EB%B2%95  
https://jbee.io/etc/what-is-good-code/#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%83%81%ED%99%A9%EB%93%A4%EC%9D%84-%EB%A7%88%EC%A3%BC%ED%95%98%EA%B2%8C-%EB%90%98%EB%8A%94%EA%B0%80

- 가장 일반적인 케이스에 대응 가능하게 짜기
- if문은 조건마다 리턴시키는게 가독성이 좋다
- 함수는 그때그때 분리
- styled 쓸때 as 사용하기 - 네이밍 겹치는 문제 해결
- props 넘길때 파라미터 없으면 함수 또만들지 않기
- 자식 컴포넌트에게 setState를 넘겨주지 않고 핸들러 만들기
- 컴포넌트 분리할때 단일 책임 원칙 
- 개방폐쇄 원칙 고려해서 자료구조에 직접 접근하지 않고 사용할 수 있는 인터페이스 제공하기
- 인터페이스 낭비하지 않기. 사용할 속성만 제공하기
- 의존성 역전 : 모듈을 적당히 격리시켜서, 수정이 광범위하게 영향을 미치고 강결합하지 않게 하기. 특히 컴포넌트와 라이브러리의 관계 잘 생각하기
- 주석은 메타데이터이기 대문에 주석의 내용과 함수의 실제 동작이 일치한다고 보장할 수 없다.
- 좋지 않은 코드가 생산되는것을 완전히 차단할 수 없다면, 제대로 관리될 수 있도록 격리해야 한다.
- 디렉토리, 어디에 분리할지. Featured base가 좋은 접근 방식인듯 하다.


## 네이밍

- 함수이름은 prefix, action, target
- 네이밍 3어절을 넘지 않게끔
- 문법은? 그렇게 크게 고민안해도 될듯?

## 컴포넌트 디자인

> Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.

### 유연한 컴포넌트

https://jbee.io/web/components-should-be-flexible/  

- 엔지니어링 측면에선 어떤 시스템을 구성하는 요소 중 하나를 컴포넌트라고 할 수 있다. 프론트엔드 애플리케이션의 경우에는 시스템을 UI로 보고 UI를 구성하는 요소를 컴포넌트라고 할 수 있다.
- **데이터 기반으로 컴포넌트를 설계한다** : deal with하는 데이터가 상이하면 컴포넌트도 분리한다. 주소 목록을 렌더링하는 리스트와 주소 목록의 요소(주소) 그리고 데이터에 대한 책임과 역할 역시 컴포넌트 분리시 적당히 분리되어야 한다.
  - 데이터 중심의 설계를 하기 위해서는 데이터 모델이 single source of truth로 관리되어야 한다.
  - source of truth에서 데이터를 prop으로 줘야 하는 경우, 수정에 대비해 데이터를 최대한 수정하거나 일부만 뽑아서 주거나 하는 일을 최소화하면 좋을 것 같다.
- 데이터에 독립적으로 만든다. 데이터를 책임질 수 있는 (네이밍을 가진) 컴포넌트에서 데이터를 가져오는(fetch) 역할을 해야한다.
- 컴포넌트 하나에서 특정 역할을 하는 요소에 책임을 분리할 수 있다면 컴포넌트 분리를 고려해볼 수 있다.
- 인터페이스는 사용하는 쪽을 위한 것이며, 인터페이스를 보고 어떻게 동작할지 예상 가능해야 한다.
- 도메인과 결합하는 컴포넌트의 재사용성을 고려해서, **인터페이스를 일반적으로 만드는게 좋은 접근이고(도메인을 모르는 컴넌), 만약에 도메인과 필수적으로 결부되어야할 컴포넌트는 도메인을 모르는 컴포넌트의 의존성(prop)으로 지정해주는 방식으로 의존성을 주입해줄 수 있다.**
  - 도메인을 이미 다 아는 컴포넌트였다면 의존성이 숨어들어갈 수 밖에 없다.
  - **일반적인 인터페이스에 element를 prop으로 의존성을 주입해주는 방식으로 사용하기**
  - 근데 처음부터 domain oriented한 경우는 어떡함?
  - 커스텀이 많아질 가능성이 있다면 외부에서 주입을 많이 해줄 수 있는 형태로 변경한다. => 그러면 거의 공통으로 사용하는 컴포넌트의 인터페이스는 스타일 요소정도밖에 없는게 되려나?
- 의존 관계가 생성되면 변경의 파장이 의존 방향에 따라 영향을 미치게 된다.
- **컴포넌트 네이밍 또한 인터페이스이기 때문에 외부와의 의존성을 만들게 된다**
  - 구현을 캡슐화하여 내부의 변경이, 외부에 영향을 미치지 않도록 해야한다.
  - 일반적인 인터페이스를 갖기 위해 내부 구현을 외부로 표현하거나, 인터페이스에 반영하거나 하면 안되는 요소들이 필요할 수 있다.
- prop이름은 예상 가능하게
  - 기본 attribute는 상속한다.(extends)
    - 나는 prop에 type을 쓰는걸 좀더 좋아하는 편인데, 이렇게 definetely type을 써야 할때는 interface를 쓰는게 좋다..
  - **요소를 프롭으로 전달할 경우 역할이 명확히 드러나는 이름이어야 한다.**
  - 널리 사용되는 네이밍을 알아보자
- 변경으로 인한 영향이 좁으면 좁을수록 변경에 유연하다.
- **이른 추상화?** : 소프트웨어는 변한다는 대전제 하에 개발은 수행된다. 역할을 기준으로 추상화하면 이른 추상화가 아니다. 나중에 리팩토링은 조삼모사, 추상화와 추출은 다르다
- 지금 당장 도메인을 알고, 여기에서만 사용한다면 분리하지 않아도 될 수 있음. 물론 컴포넌트를 분리하는 이유가 재사용에만 있는 것은 아니며, 복잡해진 컴포넌트의 복잡도를 낮추기 위해 적당히 컴포넌트로 분리하는 경우도 있다.
  - **두 컴포넌트가 의존성이 깊을때는 분리했을 경우 이상한 인터페이스를 작성해야할 수도 있다.** 이럴 경우에는 결국 필연적으로 내부를 봐야 이해가 된다. 분리안하는것 만 못함
- 구현을 미루고 어떻게 사용할지 먼저 정의하자. UI의 구조, 어떤 prop이 필요한지, 이름은 무엇이어야 할지. UI에 먼저 집중하면 컴포넌트에 도메인 맥락이 섞이지 않게 되어 일반적인 인터페이스를 설계할 수 있게 된다.
- 추출을 잘못하는게 흔히 말하는 이른 추상화다.(근데 이건 그냥 복잡성을 추가하는 방향이 잘못된 추상화인듯. 시기랑은 상관없지않나? 싶은 늒임) 컴포넌트를 분기가 많은 괴물 컴넌으로 만들지 말고 외부에서 주입받는게 낫다
  - 추상화 : 불필요한 정보를 제거하고 문제 해결에 필요한 정보만 남기는 작업. 하나의 문제에 집중하도록 모듈을 어래인지. 

### 의존성

https://tecoble.techcourse.co.kr/post/2021-11-01-component-dependency/

- 의존성 : 의존성 관리가 잘 되었을 때 예상치 못한 변경에 유연하게 대처할 수 있기 때문에 유지보수 효율이 올라간다. 
  - 불필요한 의존성을 제거하거나 약화시키고, 불가피하게 강하게 의존되는 요소들은 가깝게 둔다
- 컴포넌트는 스타일, 로직, 전역 상태, 프롭(상위 컴포넌트의 의존성)에 의존한다.
  - 넓게 보면 서버 데이터 스키마까지
  - 비슷한 관심사는 함께 두기 - 컴포넌트 내부에서만 사용하는 훅은 폴더 안에 두거나, 파일 안에 두기 -> 컴포넌트 폴더 디렉토리로 디렉토리 구조도 표현하면 좋겟다
  - 도메인을 알고 있는 컴포넌트 개선 : 전에 원지혁님 발표에서 본것처럼, id를 통해 전역적으로 관리하는 방식도 생각해볼 수 있을 듯 하다. 백엔드 스키마를 prop과 같은 인터페이스에서 알지 못하게 하는 것. 이렇게 격리하면 컴포넌트의 인터페이스는 자주 수정하지 않아도 될 것이다.
    - itemList와 item의 관계라고 생각해보면, prop으로 item에 대한 의존성을 받는게 아니라 itemList를 전역 스토어에서 받고, itemList의 인덱스를 프롭으로 받아서 그 프롭으로 하여금 전역 스토어에서 또 쿼리?
    - 전역 스토어를 리모트 레이어로 사용한다면 괜찮은 느낌인데, 그렇지 않은 경우는? cacheClient에서 받아올라나 그렇다면 또 쿼리 구조에 의존할텐데? 적절한 훅으로 데이터가 없는 상황에 대해서는 분기가 필요할 것 같다
    - 이런 경우라면 suspense 못쓸지도
  - 의존성 드러내기 : prop구조에 드러내자
  - 컴포넌트의 재사용 기준은 모델 : 역시 데이터를 기준으로 컴포넌트를 분류해야 한다. 데이터가 달라질 가능성이 있다면 컴포넌트도 분리해놓는게 좋을 수 있다.

## 프로젝트 디렉토리

## 비즈니스 로직 분리

## 상태관리

## Hook



### Custom Hook

- 컴포넌트 내부의 데이터 흐름, 로직이 한눈에 보기가 힘들다면 컴포넌트 내부 파일에서 커스텀훅으로 분리하는 방식을 사용할 수 있다. 그리고 재사용이 필요하다면 외부 디렉토리로 훅을 분리할 수 있다.
  - 원래는 가장 주요한 로직은 훅으로 분리하지 않고, 재사용이 필요한것들만 분리했는데 파일 내부라면 괜찮을 것 같다.

### useEffect 추상화

## 로직단의 추상화

## 선언형

### 선언적으로 비동기 처리

### 선언적으로 스타일과 애니메이션 처리

## 타입스크립트




