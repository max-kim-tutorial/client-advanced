# 모노레포+아키텍처 레퍼런스 정리

1000명이 써도 ㄱㅊ은 모노레포 아키텍처를 만드려면 어떻게 해야할까

## 모노레포에 필요한 기술들

### yarn berry

- node_modules의 문제점
  - 의존성 탐색 알고리즘 비효율: node에서 require()함수를 실행하면 모듈을 찾을때까지 node_modules 디렉터리를 순회한다. 이때 느린 디스크 I/O 동작이 경로의 깊이만큼 발생한다.
  - 저장 공간과 설치 시간
  - phantom dependency : 의존성 중복 방지를 위해 호이스팅 기법을 이용하는데, 이것은 의도치 않은 side-effect를 발생시킨다. 어떤 패키지가 의존하는 다른 패키지의 하위 의존성을 상위 패키지가 의존할 수 있게 되어 문제가 생긴다.
- berry는 node_modules에 패키지 파일을 다 때려박는 대신에 패키지의 압축 파일을 .yarn/cache 폴더에 수평적으로 저장하는 방식으로 위 문제를 해결했다. 이 방식을 PnP라고 부른다. 압축파일은 ZipFs를 이용해서 해당 모듈 로드가 필요할 때 메모리에서 압축을 해제하여 접근한다.
  - 모든 패키지에 대한 접근 시간은 O(1)
  - 압축 파일 단위라서 의존성을 구성하는 파일의 수가 감소한다.
  - 호이스팅을 사용하지 않으므로 의도하지 않은 의존성이 발생하지 않는다.

### `.yarn`

## 모노레포 개념과 케이스 스터디

### [모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편](https://d2.naver.com/helloworld/0923884)

- **자율성은 고립에 의해 제공되고 고립은 협업을 방해한다** : 일반적으로 팀은 애플리케이션 개발의 라이프사이클을 스스로 결정하기를 원하고 기대한다.
- 멀티레포의 문제
  - 패키지 생성이 번거롭다.
  - 고립에 의해 나눠진 레포지토리에서 패키지의 중복 코드가 발생한다.
  - 늘어난 저장소만큼 관리 포인트가 늘어난다.
  - DX가 일관성이 없어지고 다른 패키지의 변경 사항이 전파가 잘 안된다.
  - 관련 패키지의 변화가 있을 때 여러 저장소에 걸쳐 변화를 반영하는게 쉽지 않고 버저닝도 ㅈㄴ어렵다
- 멀티레포가 해결하는 지점
  - 더 쉬운 프로젝트 생성
  - 더 쉬운 의존성 관리
  - 단일화된 관리 포인트
  - 일관된 DX
  - 프로젝트에 걸친 원자적 커밋 : 커밋할때마다 모든 것이 함께 작동한다. 변경 사항의 영향을 받는 조직에서 쉽게 변화를 확인할 수 있다.
  - 서로 의존하는 저장소들의 리팩토링 비용 감소 : 100개의 라이브러리로 만든 10개의 앱을 리팩토링하고 변경을 커밋하기 전에 모두 작동하는지 확인할 수 있다.
  - 소스 변경시 모든 프로젝트를 다시 빌드하거나 테스트하지 않고, 변경 사항의 영향을 받는 프로젝트만 다시 테스트하고 빌드한다.
- 모노레포가 적절한 상황
  - 유사한 제품의 집합(!)
  - 여러 프로젝트의 변화를 한 눈에 파악해야 할 때
  - 호스트 애플리케이션을 플러그인 등으로 확장할 때
  - 공통 기능을 재사용하는 관련된 프로젝트의 집합
  - 유사한 데브옵스로 구성된 프로젝트의 집합

### [How Google Does Monorepo](https://qeunit.com/blog/how-google-does-monorepo/)

- single codebase, sharing, transverse visibility
- 구글은 1999년부터 크로늄과 안드로이드를 제외하고 모노레포를 사용했다(ㅁㅊ다)
- 2 billion lines of code representing 86 Tb of storage(????) 20억 라인? checkout 가능하긴함?
- monorepo classic difficulties
  - 체크아웃 개오래걸림
  - 파일 찾기 너무 어려움
  - 모듈 구조 가시화가 힘듬
  - 순환참조 개많이생김
  - 빌드 오케스트레이션 거의 불가능
  - 테스트 사이클이 너무 복잡해짐
- 여러 도구들 : 얘네는 레포지토리와 코드 스토리지부터 다르게 설계했다
  - Piper stores their 86 Tb of source code, a distributed storage solution at scale, supporting more than sustained request volumes.
  - 레포지토리 내부에서 접근 권한에 따라 코드 접근 여부를 다르게 할 수 있다
  - client in the cloud의 약자인 CitC 툴은 수정한 코드만 다운로드받을 수 있게 하는 프록시다
  - 다이아몬드 의존성이나 상호참조 방지
- 릴리즈를 따로 따서 trunk-based로 배포: 배포 위험성을 최소화, Main을 블락하지 않게, cherry pick
- 복잡도가 늘어나고, 사람이 많아질수록 이를 지탱하는 견고한 시스템이 필요하다.

### [Using monorepos to increase velocity during early stages of product development](https://devblogs.microsoft.com/startups/using-monorepos-to-increase-velocity-during-early-stages-of-product-development/)

## 모듈 설계와 의존성 문제

### [멀티모듈 설계 이야기 with Spring, Gradle](https://techblog.woowahan.com/2637/)

- 비즈니스 로직, 중심 도메인이 가져야할 구조와 규칙 등을 동일하게 보장해주는 매커니즘이 없음. 개발자는 비즈니스 로직을 복붙하며 개발을 하게 됨
- 멀티 모듈 프로젝트는 기존의 단일 프로젝트를 프로젝트 안의 모듈로서 갖게 할 수 있는 구조를 제공
- 공통 모듈에 핵심, 공통 코드들이 다 들어가게 되면 문제점들이 생김
- 코드는 어떠한 선택에 의해 빈번하든 아니든 공통 모듈에 점점 추가를 할 수 밖에 없음. 특정 어플리케이션을 위해 작성한 코드들을 다른 애플리케이션에 쓰게 됨. 이러면서 공통 모듈은 걷잡을 수 없이 커질수 밖에 없음. 공통 모듈에서 너무 많은 일을 하게 됨
- 공통 모듈의 남용은
  - **리팩토링을 방해함** : 청산해야할 코드가 자연스럽게 시스템 전체에 영향을 미치는 일이 발생하게 됨. 코드가 꼬리를 물고 하나의 코드만 수정해도 전체가 영향받는 현상은 불가피하다. 공통 모듈에 들어간 코드는 더이상 처음 작성한 의도만을 위한 코드가 아니게 된다. 공통이기 때문에, 오너쉽도 좁혀지지 않아 남용하기 더 쉽게 된다
  - **공통 모듈의 의존성은 결국 전부가 된다** : 공통 모듈에서 가져다 쓰는 애플리케이션단을 위해 온갖 의존성들을 하나의 모듈에 덕지덕지 붙이게 된다. 프로젝트에서 사용하는 대부분의 의존성이 **공통 모듈로부터 시작된다**
  - 공통 설정을 공통 모듈로 몰면 큰일난다 : 내용만 같다고 공통으로 볼 수 있는게 아니고, 충분히 미래에 변경될 수 있거나 민감한 정보들은 어플리케이션단에서 따로 만들어줘야 한다.
- 멀티 모듈은 독립적으로 실행가능한 어플리케이션 모듈을 1개 이상 가지고 있으며 사용하는 인프라 자원 역시 1개 이상을 가지고 있음. 독립적으로 실행 가능한 어플리케이션들은 당연히 서로 다른 책임과 역할을 가지므로, 위에서 말한 문제를 피하기 위해 하위 모듈들에 대한 의존성과 사용성에 대한 개방 폐쇄를 철저히 해야만 한다.
- **멀티 모듈은 레이어의 관점에서 보는게 아니다** : 의존 라이브러리가 모두 모듈임. 모듈은 독립적인 의미를 갖으며, 어떠한 추상화 정도에 대한 **계층**을 가지고 있으며, 계층간 의존 관계에 대한 규칙이 있다.

### 계층화

- 독립 모듈 계층 : 프로젝트 내에서 가장 프로젝트와 **성격이 먼 모듈**이 아래 계층에 위치한다. 시스템, 도메인 비지니스와 전혀 별게로 자체 제작한 라이브러리 같은 모듈이 이 계층에 들어간다.
- 공통 모듈 계층 : 하나의 프로젝트에서 모든 모듈에서 사용될 수 있는 것들은 나올 수 밖에 없어서 만들어진 계층. **왠만하면 사용하지 않아야 하고** Type, Util등을 정의하는 얕은 계층이다.
- 도메인 모듈 계층 : 시스템의 중심 도메인을 다루는 모듈. 서비스 비지니스를 모르고, 하나의 모듈은 하나의 인프라스트럭처에 대한 책임만 가진다(백엔드에서는 Redis나 RDB). 도메인 모듈을 조합한 더 큰 단위의 도메인 모듈이 있을 수 있음. 프로젝트 안의 어떠한 실행 가능한 어플리케이션에서도 사용 가능한 모듈을 위치시킨다.
- 내부 모듈 계층 : 저장소와 도메인 외에 시스템에서 필요한 모듈이 속하는 계층. 시스템과는 연관이 있다. 어플리케이션과 도메인 비즈니스는 여전히 몰라야 한다.
- 무엇이든 끌어다 쓸 수 있게 된다는 측면에서 초기에는 개발이 빠르지만, 그로인해 만들어지는 스파게키 의존으로 점차 개발 생산성이 떨어진다.
- 의존성이 복잡하면 의존성을 가짐으로써 동작하는 모종의 동작이 예측 가능한 소프트웨어를 만들기 힘들게 한다.

#### 남는 의문

- 역할과 책임을 레이어에 어떻게 분산해놓을 것인가?
- 자바에서는 좀더 세분화된 추상화가 가능함. 인터페이스는 낮은 계층에 놓고, 구현은 위 계층에서 하는 등...근데 노드에서는...안될테고...
- Node에서는?? React에 의존하는 서비스 레이어는?? 멀티모듈보다 큰 모노레포 환경에서는??

### [Yarn berry workspace를 활용한 프론트엔드 모노레포 구축기](https://techblog.woowahan.com/7976/)

- 다른 방식으로 구축한 모노레포에서는 루트에 공통으로 쓸 패키지를 선언해 설치하고 각 프로젝트에서는 특별히 사용하는 패키지만 의존성에 추가하는 방식을 사용하는데, 이 방식은 node_modules가 패키지를 찾는 방식(= 호이스팅)에 기대고 있는 방식이라 yarn berry workspace로 구현한 모노레포에는 통하지 않습니다. 따라서 각 패키지에서 쓸 모듈은 루트에 패키지를 추가했는가와는 상관없이 무조건 하위 프로젝트의 의존성으로도 추가해 주어야 합니다.

### [The Monorepo Blueprint – How To Create A Scalable Architecture For An Angular Monorepo](https://christianlydemann.com/how-to-create-a-scalable-architecture-for-an-angular-monorepo/)

- 좋은 모듈 구조
  - 추상화 레이어를 사용해 UI를 비즈니스 로직과 분리해야 한다
  - UI는 상태 관리하는 구체적인 툴과 디커플되어야 한다
  - 도메인 날리지를 반영하고 기술적인 세부사항을 반영해서는 안된다
  - 설계는 모듈의 경계와 의존성 주입, 캡슐화를 강제할 수 있어야 한다.
- UI와 데이터 엑세스 로직은 분리되어 모듈화되어야 하고, 어떠한 계층(sandbox)에서만 할당하는 식으로 서로 결합한다.
- 라이브러리는 코드 공유를 위해서만 존재하는 것은 아니고, 모듈의 캡슐화를 강제하기 위해서도 존재한다. 프론트엔드에서는 이런 은닉을 index를 통해서 할 수 있다.
- sandbox: 비즈니스 로직을 가지고있는 파사드. 사용하기 좋은 인터페이스를 통해 데이터를 가져온다. 샌드박스의 인터페이스는 기술적인 것을 모름
  - 리덕스로 따지면 액션과 디스패치를 밖에서 가져오는 그런 느낌?
  - 리모트 레이어를 파사드라고 부를 수 있나????? 뭐 그럴지도.. 인터페이스 쓸만한가?
  - 앱에 영향을 미치지 않고 상태와 관련된 도구들을 갈아치울 수 있게끔
- UI랑 비즈니스 로직 분리하고, UI랑 비즈니스 로직이 합쳐지는 레이어가 따로 있어서 거기에서 합쳐져가지구 앱으로 오는 방향
