# 리액트 클린 코드

과제 전형 대비해서,, 좀 정리해보자  
어째 미디엄엔 리액트 코드컨벤션 이야기가 많은것 같긔 

## 리액트 클린코드 기본

https://velog.io/@hyounglee/checklist-codereview  
https://velog.io/@huurray/SOLID-%EC%9B%90%EC%B9%99%EC%97%90-%EA%B8%B0%EC%B4%88%ED%95%9C-React-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%EB%B2%95  
https://jbee.io/etc/what-is-good-code/#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%83%81%ED%99%A9%EB%93%A4%EC%9D%84-%EB%A7%88%EC%A3%BC%ED%95%98%EA%B2%8C-%EB%90%98%EB%8A%94%EA%B0%80

- **가장 일반적인 케이스에 대응 가능하게 짜기** : 책임과 역할을 최대한 마이크로하게 분리
- if문은 조건마다 리턴시키는게 가독성이 좋다
- 함수는 그때그때 분리
- props 넘길때 파라미터 없으면 함수 또만들지 않기
- 자식 컴포넌트에게 setState를 넘겨주지 않고 핸들러 만들기
- 컴포넌트 분리할때 단일 책임 원칙 
- 개방폐쇄 원칙 고려해서 자료구조에 직접 접근하지 않고 사용할 수 있는 인터페이스 제공하기
- **인터페이스 낭비하지 않기. 사용할 속성만 제공하기**
- **의존성 역전 : 모듈을 적당히 격리시켜서, 수정이 광범위하게 영향을 미치고 강결합하지 않게 하기. 특히 컴포넌트와 라이브러리의 관계 잘 생각하기**
- 주석은 메타데이터이기 대문에 주석의 내용과 함수의 실제 동작이 일치한다고 보장할 수 없다.
- **좋지 않은 코드가 생산되는것을 완전히 차단할 수 없다면, 제대로 관리될 수 있도록 격리해야 한다.** -> 주석, 모듈
- 디렉토리, 어디에 분리할지. Featured base가 좋은 접근 방식인듯 하다.
- useEffect 관심사별로 분리하기 -> 커스텀훅
- 값과 key가 똑같은 prop 이름 넘길때 `{...{props}}` 로 넘기기
- **import 경로문 길어지는거 reexport로 방지하기** -> 이거 부작용은 없나? 뭔가 `index` 라는 파일명이 이런 용도에서 온 것일까?, 이거 개발할때마다 재깍재깍 해줘야 나중에 귀찮은 일이 업다..
- state 객체로 합칠때 관심사 고려. 만약 관심사가 다르다면 다른 useState 구문으로 분리해야 한다.
- IOC를 리액트 개발에 적용해보기 : 내부에서 구현하는게 아니라, 외부에서 주입받는 방식으로, **해당 컴포넌트, 모듈이 하나의 일에만 집중하도록 바꾸기. 근데 모든 요소가 의존성을 주입받는 형태로 바뀌어야할 필요는 없다.** 도메인에 의존하는 컴포넌트라면, 관련된 기능들은 한 곳에 모아져놓는게 로직을 더 빠르게 찾자는 측면에서는 더 좋을수도 있음
  - 인터페이스는 동일하게 하고, 다른 파라미터를 주입해서 다른 함수 호출이 가능한 형태로 만들기 -> 다형성
- for loop : 쌩for문은 빠른 대신에 가독성이 좋지 않다. forEach는 가독성도 괜찮고 적당한 속도를 가졌지만 중간에 인터럽트를 못한다. 

## 네이밍

- 함수이름은 prefix, action, target
- 네이밍 3어절을 넘지 않게끔
- 문법은? 그렇게 크게 고민안해도 될듯?

## 컴포넌트 디자인

> Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.

### 컴포넌트 선언 컨벤션

kent는 이렇게 한다고(나랑 똑같당!)

```jsx
// 선언식
function Counter() {
  const [count, setCount] = React.useState(0);
  const increment = () => setCount(c => c + 1); // 표현식
  return <button onClick={increment}>{count}</button>
}
```

- 콜백함수 사용할때 함수 표현식, 객체의 속성으로 사용할 때는 함수 표현식, 2가지 상황이 아닐 경우 함수 선언식 사용
- 함수 선언식은 호이스팅이 되어 함수 변수와 내용까지 모두 그대로 위로 끌어올려지기 때문에 호출하는 순서가 상관이 없게 된다. => 근데 가끔 이거때문에 위험하지 않을까? 싶기도 함. 호출 순서때문에 프로그램이 뒤죽박죽되서 디버깅하고 고치기 어렵게 될수도 있다. 근데 kent는 이게 편하다고 함
- 나같은 경우 React.FC 반환 타입은 굳이 사용할 이유는 없는것 같고, 컴포넌트를 선언식으로 작성하는 것은 리액트의 오랜 관행이기 때문에 계속 따랐던 것 같다.

### 유연한 컴포넌트

https://jbee.io/web/components-should-be-flexible/  

- 엔지니어링 측면에선 어떤 시스템을 구성하는 요소 중 하나를 컴포넌트라고 할 수 있다. 프론트엔드 애플리케이션의 경우에는 시스템을 UI로 보고 UI를 구성하는 요소를 컴포넌트라고 할 수 있다.
- **데이터 기반으로 컴포넌트를 설계한다** : deal with하는 데이터가 상이하면 컴포넌트도 분리한다. 주소 목록을 렌더링하는 리스트와 주소 목록의 요소(주소) 그리고 데이터에 대한 책임과 역할 역시 컴포넌트 분리시 적당히 분리되어야 한다.
  - 데이터 중심의 설계를 하기 위해서는 데이터 모델이 single source of truth로 관리되어야 한다.
  - source of truth에서 데이터를 prop으로 줘야 하는 경우, 수정에 대비해 데이터를 최대한 수정하거나 일부만 뽑아서 주거나 하는 일을 최소화하면 좋을 것 같다.
- 데이터에 독립적으로 만든다. 데이터를 책임질 수 있는 (네이밍을 가진) 컴포넌트에서 데이터를 가져오는(fetch) 역할을 해야한다.
- 컴포넌트 하나에서 특정 역할을 하는 요소에 책임을 분리할 수 있다면 컴포넌트 분리를 고려해볼 수 있다.
- 인터페이스는 사용하는 쪽을 위한 것이며, 인터페이스를 보고 어떻게 동작할지 예상 가능해야 한다.
- 도메인과 결합하는 컴포넌트의 재사용성을 고려해서, **인터페이스를 일반적으로 만드는게 좋은 접근이고(도메인을 모르는 컴넌), 만약에 도메인과 필수적으로 결부되어야할 컴포넌트는 도메인을 모르는 컴포넌트의 의존성(prop)으로 지정해주는 방식으로 의존성을 주입해줄 수 있다.**
  - 도메인을 이미 다 아는 컴포넌트였다면 의존성이 숨어들어갈 수 밖에 없다.
  - **일반적인 인터페이스에 element를 prop으로 의존성을 주입해주는 방식으로 사용하기**
  - 근데 처음부터 domain oriented한 경우는 어떡함?
  - 커스텀이 많아질 가능성이 있다면 외부에서 주입을 많이 해줄 수 있는 형태로 변경한다. => 그러면 거의 공통으로 사용하는 컴포넌트의 인터페이스는 스타일 요소정도밖에 없는게 되려나?
- 의존 관계가 생성되면 변경의 파장이 의존 방향에 따라 영향을 미치게 된다.
- **컴포넌트 네이밍 또한 인터페이스이기 때문에 외부와의 의존성을 만들게 된다**
  - 구현을 캡슐화하여 내부의 변경이, 외부에 영향을 미치지 않도록 해야한다.
  - 일반적인 인터페이스를 갖기 위해 내부 구현을 외부로 표현하거나, 인터페이스에 반영하거나 하면 안되는 요소들이 필요할 수 있다.
- prop이름은 예상 가능하게
  - 기본 attribute는 상속한다.(extends)
    - 나는 prop에 type을 쓰는걸 좀더 좋아하는 편인데, 이렇게 definetely type을 써야 할때는 interface를 쓰는게 좋다..
  - **요소를 프롭으로 전달할 경우 역할이 명확히 드러나는 이름이어야 한다.**
  - 널리 사용되는 네이밍을 알아보자
- 변경으로 인한 영향이 좁으면 좁을수록 변경에 유연하다.
- **이른 추상화?** : 소프트웨어는 변한다는 대전제 하에 개발은 수행된다. 역할을 기준으로 추상화하면 이른 추상화가 아니다. 나중에 리팩토링은 조삼모사, 추상화와 추출은 다르다
- 지금 당장 도메인을 알고, 여기에서만 사용한다면 분리하지 않아도 될 수 있음. 물론 컴포넌트를 분리하는 이유가 재사용에만 있는 것은 아니며, 복잡해진 컴포넌트의 복잡도를 낮추기 위해 적당히 컴포넌트로 분리하는 경우도 있다.
  - **두 컴포넌트가 의존성이 깊을때는 분리했을 경우 이상한 인터페이스를 작성해야할 수도 있다.** 이럴 경우에는 결국 필연적으로 내부를 봐야 이해가 된다. 분리안하는것 만 못함
- 구현을 미루고 어떻게 사용할지 먼저 정의하자. UI의 구조, 어떤 prop이 필요한지, 이름은 무엇이어야 할지. UI에 먼저 집중하면 컴포넌트에 도메인 맥락이 섞이지 않게 되어 일반적인 인터페이스를 설계할 수 있게 된다.
- 추출을 잘못하는게 흔히 말하는 이른 추상화다.(근데 이건 그냥 복잡성을 추가하는 방향이 잘못된 추상화인듯. 시기랑은 상관없지않나? 싶은 늒임) 컴포넌트를 분기가 많은 괴물 컴넌으로 만들지 말고 외부에서 주입받는게 낫다
  - 추상화 : 불필요한 정보를 제거하고 문제 해결에 필요한 정보만 남기는 작업. 하나의 문제에 집중하도록 모듈을 어래인지. 

### 의존성

https://tecoble.techcourse.co.kr/post/2021-11-01-component-dependency/

- 의존성 : 의존성 관리가 잘 되었을 때 예상치 못한 변경에 유연하게 대처할 수 있기 때문에 유지보수 효율이 올라간다. 
  - 불필요한 의존성을 제거하거나 약화시키고, 불가피하게 강하게 의존되는 요소들은 가깝게 둔다
- 컴포넌트는 스타일, 로직, 전역 상태, 프롭(상위 컴포넌트의 의존성)에 의존한다.
  - 넓게 보면 서버 데이터 스키마까지
  - 비슷한 관심사는 함께 두기 - 컴포넌트 내부에서만 사용하는 훅은 폴더 안에 두거나, 파일 안에 두기 -> 컴포넌트 폴더 디렉토리로 디렉토리 구조도 표현하면 좋겟다
- 도메인을 알고 있는 컴포넌트 개선 : 전에 원지혁님 발표에서 본것처럼, id를 통해 전역적으로 관리하는 방식도 생각해볼 수 있을 듯 하다. 백엔드 스키마를 prop과 같은 인터페이스에서 알지 못하게 하는 것. 이렇게 격리하면 컴포넌트의 인터페이스는 자주 수정하지 않아도 될 것이다.
    - itemList와 item의 관계라고 생각해보면, prop으로 item에 대한 의존성을 받는게 아니라 itemList를 전역 스토어에서 받고, itemList의 인덱스를 프롭으로 받아서 그 프롭으로 하여금 전역 스토어에서 또 쿼리?
    - 전역 스토어를 리모트 레이어로 사용한다면 괜찮은 느낌인데, 그렇지 않은 경우는? cacheClient에서 받아올라나 그렇다면 또 쿼리 구조에 의존할텐데? 적절한 훅으로 데이터가 없는 상황에 대해서는 분기가 필요할 것 같다
    - 이런 경우라면 suspense 못쓸지도
  - 의존성 드러내기 : prop구조에 드러내자
  - 컴포넌트의 재사용 기준은 모델 : 역시 데이터를 기준으로 컴포넌트를 분류해야 한다. 데이터가 달라질 가능성이 있다면 컴포넌트도 분리해놓는게 좋을 수 있다.

### render props 패턴, children

```jsx
<DataProvider render={data => (
  <h1>Hello {data.target}</h1>
)}/>
```

- React 컴포넌트 간에 코드를 공유하기 위해 함수 props를 이용하는 테크닉
- 부모 컴포넌트 안에 자식 컴포넌트의 의존성을 숨겨서 부모 컴포넌트를 보아야만 어떤 컴포넌트를 렌더링하는지 파악하게 만들지 않고, 함수 props을 사용해 의존성을 드러내는 테크닉이다. render prop은 무엇을 렌더링할지 컴포넌트에게 알려주는 함수이다. 컴포넌트들은 행위를 쉽게 공유할 수 있게 된다.
- HOC를 render props를 쓰면 대부분 리팩토링할 수 있다.
- pureComponent랑 쓰면 최적화의 이득을 보기 힘들다.
- children과 다른 점이라면, 자식 컴포넌트 인터페이스, 의존성을 부모 컴포넌트에서 조금더 자세하게 작성할 수 있다는거? prop으로 들어오는 것들이 렌더링되는 값과 어떻게 의존하는지 자세히 표현해줄 수 있을듯 하다.
- 남발하면 children을 쓰는 것보다 더 복잡해지고, renderProps로 처리하는 UI가 크고 복잡할수록 더더 복잡해진다. 자식 컴포넌트의 의존 구조를 부모 컴포넌트에서 드러내는게 이득이 있을 때만 사용해야한다.
- HOC의 대체제로써? 선호되는거 같음? 

```jsx
// children의 프롭타입은 Mouse=>ReactNode 이런식일 것임
<Mouse mouse={mouse} children={mouse => (
  <p>The mouse position is {mouse.x}, {mouse.y}</p>
)}/>

// children으로 하면서 의존구조 노출시키는 경우
<Mouse>
  {mouse => (
    <p>The mouse position is {mouse.x}, {mouse.y}</p>
  )}
</Mouse>

// 그냥 children props
<Mouse children={<p>The mouse position is {mouse.x}, {mouse.y}</p>}/>
```

- react hook form에서 좋은 예제를 봤었던것 같은데..?
- **children이 하나이고, 인터페이스 노출 없이 자식으로 렌더링할 요소가 명확하다면, 바로 자식 아래다 넣는 방식으로 jsx를 작성하는 방식이 좋은 것 같다. 여러개의 JSX가 동시에 들어가야한다면 prop쪽이 낫고**
- children의 또다른 장점은 원래 prop drilling으로 해결했던 부분들을 한 컴포넌트에다가 합성으로 구현할 수 있다는 것이다. **의존성을 숨기지 않고 최상위 컴포넌트에 드러낼 수 있게 한다.**
- 어떤 역할을 하는 컴포넌트가 children을 가지고 저런식으로 책임을 분리할 수 있을지는 그때그때 다를듯
## 최적화, 메모이제이션

https://medium.com/@predragdavidovic10/usememo-why-when-how-e045b7dade82

- useMemo는 expensive computation을 피하거나 자식 컴포넌트의 비싼 리렌더를 피하는데 사용
- 비싼 연산을 setState하는 연산과 분리해서 따로 메모이제이션 하도록 추출해낼 수도 있다.
- ReactNode의 useMemo : state가 바뀔 때면 자식 컴포넌트가 모두 리랜더링되기 마련인데, 자식 컴포넌트를 메모이제이션 하는 방식으로 방지할 수 있음. 부모 컴포넌트에서 특정 프롭이 바뀌었을때만 render => 자식단에서의 react.memo랑 비슷한데 부모단에서 이렇게 할 수 있겠네. 그런데 이렇게 하믄 자식 컴포넌트의 메모이제이션 여부를 알기 위해 부모 컴포넌트를 봐야 하는데, 좋은 관심사 분리는 아닌거 같다.

```jsx
// 쓸일이 많지는 않겠지만 이렇게도 된다는 것을 알기 위해..
// 근데 난 언제나 함수 리턴문 위에 JSX가 존재하는게 불편하다..
const MemoizedComponent = useMemo(
  () => <Component text={text} />,
  [text]
)
```
- webpack5 : 여러 최적화 옵션들 때문에 웹 메트릭이 더 좋아진다.
- 최대한 상태별로 UI를 구분하고, 관련 없는 상태 때문에 UI가 얼마나 빈번하게 업데이트 되는지 살펴봐야 한다. 그런 경우가 있다면 잘못 나눠졌거나, 그렇게밖에 유지할 수 없다면 React.memo같은거 적용 검토해본다

### 언제 쓰지?

useMemo와 useCallback은 발적화의 가능성이 높기 때문에 의미없는 useMemo나 useCallback은 없어야 한다. 또한, 매번 모든 순간 렌더링을 최적화할 필요도 없다.

- 필요없는 메모이제이션을 사용하지 않는다
  - 특정 컴포넌트의 메모이제이션이 특정 프롭들 중 아주 잘 바뀌는 프롭과 의존하고 있다면 의미가 없다. 이거는 그냥 매 랜더링마다 함수가 만들어지는 로직과 다를게 없기 때문이다.
  - 특정 컴포넌트가 단 한번만 렌더링되는 것이 보장되는 상황이라면 걔네도 굳이 메모이제이션이 필요 없을 것이다.
- 레퍼런스 비교가 필요할때 메모이제이션을 사용한다 : (피하는게 좋겠지만) 개발하다보면 useEffect 등에 직접 state값을 넣는 것보다, state를 의존성으로 가지는 메모이제이션 로직을 useEffect에 넣어야 하는 상황도 충분히 생길 수 있다. 이때는 메모이제이션을 통해 useEffect가 제대로 동작하도록 함수를 useCallback등으로 감싸야 한다.
- 렌더링을 줄여주는 방식으로 메모이제이션을 사용한다 : 유저 인터랙션(거듭된 토글이나 스크롤, 인터벌) 등으로 많은 리랜더링이 불가피할 경우 메모이제이션으로 최적화한다.
  - 근데 사실 이것도 발적화일...수도 있다. 리랜더링 자체를 그렇게 너무 통제하려고 하지 말라는 개발자들도 좀 많은듯 함. 확실히 성능에 영향이 있는 경우에만 인스펙션해서 적용해야 할지도..? 이건 근데 실무를 더 경험해봐야 할 것 같기도 하다.
- 부모 컴포넌트 랜더링이 너무 자주 일어나서 자식 컴포넌트의 랜더링도 덩달아 많이 일어나는 경우에는 React.memo 래퍼를 사용한다.
  - 애초에 설계가 잘못된 걸수도 있다는 생각을 좀 해볼 수 있지 않을까 싶긴 하다. 불가피한 경우인지 타진한다!
  - 애초에 리렌더링을 많이 피해야한다 : 컴포넌트 내부 state은 정말 필요한 최소만 선언하고, 데이터 패칭 로직은 그것을 소비하는 컴포넌트와 최대한 가깝게 위치시키는게 좋다. 상태 끌어올리기도 신중하게 하자.

## Hook
### Custom Hook

- 컴포넌트 내부의 데이터 흐름, 로직이 한눈에 보기가 힘들다면 컴포넌트 내부 파일에서 커스텀훅으로 분리하는 방식을 사용할 수 있다. 그리고 재사용이 필요하다면 외부 디렉토리로 훅을 분리할 수 있다.
  - 원래는 가장 주요한 로직은 훅으로 분리하지 않고, 재사용이 필요한것들만 분리했는데 파일 내부라면 괜찮을 것 같다.
  - 근데 파일 내부가 결국 복잡해진다면? 이때는 분리하는게 나을지도?
### useContext 

- Context API의 쓰임새 : 상태 관리 툴로 사용하기에는 최적화가 하나도 안 되어있고, 프로바이더를 계속 감싸줘야 하는 불편함도 있기 때문에 내가 보기에 context API는 props drilling을 피하고 컴포넌트들을 뛰어넘어서 어떤 값을 전달할 수 있게 하는 low한 API에 가까운 것 같다. 실제로 이 컨셉을 토대로 여러 라이브러리들이(Recoil이라던가) 만들어졌다. 고로 프롭 드릴링이 심하게 일어날 수 있는 부모 컴포넌트에서 부분적으로 사용할 수는 있겠으나 상태관리로는 좀 불편한 점이 많다고 생각. 
  - context API가 상태관리와 관련되면서 잘못 마케팅되고 있다는 생각이 든다
### useEffect

https://blog.battlefy.com/how-to-escape-react-hooks-hell-a66c0d142c9e

- 이름을 부여하는 방법 : useEffect와 useLayoutEffect는 react가 제공하는 기본 훅들 중에서 유일하게 네임스페이스가 없는 훅이라서 useEffect 콜백 내부와 디펜던시 배열을 봐야만 얘가 뭐하는 얜지 파악을 할 수 있다.
  - 커스텀 훅으로 분리하는 방법 : 근데 커스텀훅의 접근방식은 관심사 분리를 위해서이기도 하기 때문에 useEffect나왔다고 무지성 커스텀훅으로 감싸버리는건 좋은 접근은 아니다.
  - useEffect 내부에 이름있는 함수를 선언하고 호출하는 방법 : useEffect가 실행될 때 새로운 함수가 생성되고 실행되게끔 만든다. 외부로부터의 함수 의존성을 줄일 수 있다. => 요새는 이걸 선호하고 있다
  - useCallback에다가 로직과 의존성을 선언하고 useEffect의 의존성으로 두고 호출하는 방법 : 가장 먼가 깔끔해보이고, 함수를 계속 생성하는 것을 막는 방법이긴 한데 의존성이 useEffect에서 useCallback으로 이동해 관심사 분리가 올바르게 되지 않을 수 있고, useCallback로직을 찾는데 시간을 소비할 수도 있다.
    - 그런데 함수를 useEffect에 넣을 수 없는 상황이라면 이 방법을 택해야 할 수도 있을 것 같다. useEffect 완벽 가이드에서 봤다.
- 몇개의 컨벤션
  - state을 init하기 위해 useEffect를 사용하는것은 낭비다
  - props를 computed할때는 useMemo를 사용해라 : 이거 이렇게하는거 선언적이고, 인터페이스 측면에서 이득이 있다는건 인정하는데 필요없는 메모이제이션, 메모리 사용일수도 있지 않나? 비동기 요청같은게 필요하다면, useEffect를 쓰는게 맞겠지만?
    - 그런데 사실 useEffect의 의존성 배열 내부의 값으로 들어가긴 해야하고, state에 집어넣는 동작보다 낭비가 없다고 말할 수 있나? 측정 필요
    - state가 이미 있는데 추가적인 메모리 공간을 잡아먹을 수 있다는건 경계해야될 거 같긴 한데..? 다른분들 의견이 궁금타
    - 인터페이스적인 이점을 얻기 위해, 다른 API를 사용하면서 메모리를 더 쓰는 것은 옳은가?
  - 참조 타입 프롭을 넘기지 마라 : 이거는 왠만한 상황에서 동의. 만약에 참조형 데이터를 prop으로 넘길 일이 있다면 메모이제이션, 참조 동일성을 보장할 수 있는 수단이 필요할 것.
  - useMemo 남발하지 말 것 + 내부에 컴포넌트를 선언하지 말 것 : 컴포넌트가 비싼 연산을 계속 하게끔 만들고, 발적화를 남발할 가능성을 높인다.


## 선언형
## 타입스크립트

https://ui.toast.com/weekly-pick/ko_20210505

- 장점 : reduce the cognitive load of developers by providing interface type hints and catch potential errors in realtime as you’re programming. 
- 컴포넌트에 제네릭 사용하기 : 컴포넌트의 prop 하나가 한개 이상의 타입을 받을 수 있는데 그걸 컴포넌트를 호출하는 곳에서 같이 명시하고 싶을때 사용하면 좋을 것 같다. 레이아웃 등 일반적인 인터페이스를 가지고 어느 한 문제에 집중하는 컴포넌트에서 활용해보면 좋을 듯 싶다. 다만 타입스크립트는 제네릭 타입을 좁혀서 추론하지 못한다. 타입스크립트가 이해하지 못하는, 특정 props가 들어갔을때 컴포넌트의 특정한 선택적인 동작을 명시하기 위해 단언을 사용할 수도 있다.
```tsx
// 어떤 타입이 올지 모르겠으나 id타입은 꼭 있을 것이다
// any쓰는것보다야 엄청 낫다
// 일반적인 인터페이스를 만들기 위해 좋을 것 같당
const List = <ItemType extends {id: string}>(props: {
  items: ItemType[];
  renderItem: (item: ItemType) => React.ReactNode;
}) => (
  <ul>
    {props.items.map(item => (
      <li key={item.id}>{props.renderItem(item)}</li>
    ))}
  </ul>
);
```
- 타입스크립트, 함수 컴넌 상황에서 defaultProps : default props를 함수 객체에 직접 바인딩하는 방법은 ES6 이전의 방법이라고 한다. [댄이 deprecated](https://twitter.com/dan_abramov/status/1133878326358171650)될거라고 한다. 하긴 자연스럽게 자바스크립트 문법으로 해결할 수 있는데 비직관적으로 함수객체에 바인딩하는게 좋지는 않을 것이다.
- 컴포넌트의 타입선언 : React.FC와 함께 컴포넌트 prop 타입선언을 하면, children이 포함되어있는 형태라 모든 props들이 리터럴하게 드러나지 않는다. children의 타입은 꼭 ReactNode가 아닐 수 있기 때문에(String이나 null일수도 있음) 타입이 명시되는게 더 좋다. 그리고 Compound component만들때 가독성이 더 떨어진다.
```tsx 
const  Select: React.FC<SelectProps> & { Item: React.FC<ItemProps> } = (props) => {/* ... */ }
Select.Item = (props) => { /*...*/ }
```

## 보안

흥미로워서 정리해본다  
https://medium.com/nerd-for-tech/13-ways-to-secure-your-react-js-application-dc298899ae67

XSS 공격은 공격자가 앱에 이상한 스크립트를 입력해서 실행시킬 수 있을 때 성공한다. 고로 React앱의 입력창 등에 코드가 삽입되지 않도록, 혹은 불확실한 링크로 이동하지 않도록 방어해야한다.

- jsx내부에서 `{}` 쓰면 리액트는 자동으로 escape해서 XSS를 방어하도록 한다.
- 이상한 URL이 내부에서 링킹되지 않도록 해야한다. a태그로 가는 url들은 http 프로토콜을 붙인다던가 그런 방법 가능
- 이름이 무시무시한... `dangerouslySetInnerHTML`을 쓸때는 DOMPurify와 같은 라이브러리를 사용해 sanitize해야한다. DOM에서 문제있는 것들(주로 스크립트, invalid한 태그, iframe)을 걸러낸다. 
- 코드에 DOM에 직접 접근하는 방식으로 DOM 내용을 조작하면 보안에 취약하다
```js
this.myRef.current.innerHTML = attackerControlledValue; // 이런거
// 차라리 setInnerHtml을 사용하고, sanitization을 해라
```
- SSR할때 사용하는 `ReactDOMServer.renderToString()`나 `ReactDOMServer.renderToStaticMarkup()`은 이스케이핑을 지원한다. 저런 함수를 써서 HTML을 만들어내고 난 후에 HTML에 추가적인 정보를 입력하거나 수정하면 취약하다. 저 함수의 반환값이 최종 결과물이어야 한다.
- 디펜던시가 보안 취약점을 가지고 있는지 확인해야 한다.
- `window.__PRELOADED_STATE__` 에 할당할때 JSON이 valid한지 점검해야한다.
- 민감하고 중요한 데이터는 `JSON.stringify`하지 않는다.
- 리액트의 보안 이슈를 확인해라
- 린터도 안전한거 사용해야한다. 자칫하면 내 의도와 상관없이 코드를 바꾼다. [이런게](https://github.com/snyk-labs/eslint-config-react-security/)있군


